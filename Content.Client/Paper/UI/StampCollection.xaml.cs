using System.Linq; // Add this for LINQ
using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Random;
using Content.Shared.Paper;

namespace Content.Client.Paper.UI;

[GenerateTypedNameReferences]
public sealed partial class StampCollection : Container
{
    private List<StampWidget> _stamps = new();
    private List<StampWidget> _signatures = new(); // Separate list for signatures

    /// Seed for random number generator to place stamps deterministically
    public int PlacementSeed;

    public StampCollection()
    {
        RobustXamlLoader.Load(this);
    }

    /// <summary>
    /// Remove any stamps and signatures from the page
    /// </summary>
    public void RemoveStamps()
    {
        _stamps.Clear();
        _signatures.Clear();
        InvalidateArrange();
    }

    /// <summary>
    /// Adds a stamp or signature to the display; will perform
    /// automatic layout.
    /// </summary>
    public void AddStamp(StampWidget s)
    {
        if (s.StampInfo.Type == StampType.Signature)
        {
            _signatures.Add(s); // Add to signatures list
        }
        else
        {
            _stamps.Add(s); // Add to stamps list
        }
        AddChild(s);
    }

    protected override Vector2 ArrangeOverride(Vector2 finalSize)
    {
        var random = new Random(PlacementSeed);
        var r = (finalSize * 0.5f).Length();
        var dtheta = -MathHelper.DegreesToRadians(90);
        var thisCenter = PixelSizeBox.TopLeft + finalSize * UIScale * 0.5f;

        ArrangeItems(_stamps, random, thisCenter, r, dtheta, finalSize);
        var signatureOffset = new Vector2(0, r * 0.5f); 
        ArrangeItems(_signatures, random, thisCenter + signatureOffset, r * 0.5f, dtheta, finalSize);

        return finalSize;
    }

    private void ArrangeItems(List<StampWidget> items, Random random, Vector2 center, float radius, float dtheta, Vector2 finalSize)
    {
        var theta0 = random.Next(0, 3) * dtheta;
        
        // Here's where we lay out the stamps. The first stamp goes in the
        // center of this container; subsequent stamps will chose an angle
        // (theta) to place the center of the stamp. The stamp is moved out
        // as far as it can in that direction, taking the size and
        // orientation of the stamp into account.
        for (var i = 0; i < items.Count; i++)
        {
            var stampOrientation = MathHelper.DegreesToRadians((random.NextFloat() - 0.5f) * 10.0f);
            items[i].Orientation = stampOrientation;

            var theta = theta0 + dtheta * 0.5f + dtheta * i + (i > 4 ? MathF.Log(1 + i / 4) * dtheta : 0);
            var childCenterOnCircle = center;
            if (i > 0)
            {
                childCenterOnCircle += new Vector2(MathF.Cos(theta), MathF.Sin(theta)) * radius * UIScale;
            }

            var childHeLocal = items[i].DesiredPixelSize * 0.5f;
            var c = childHeLocal * MathF.Abs(MathF.Cos(stampOrientation));
            var s = childHeLocal * MathF.Abs(MathF.Sin(stampOrientation));
            var childHePage = new Vector2(c.X + s.Y, s.X + c.Y);
            var controlBox = new UIBox2(PixelSizeBox.TopLeft, PixelSizeBox.TopLeft + finalSize * UIScale);
            var clampedCenter = Clamp(Shrink(controlBox, childHePage), childCenterOnCircle);
            var finalPosition = clampedCenter - childHePage;
            var finalPositionAsInt = new Vector2i((int)finalPosition.X, (int)finalPosition.Y);
            items[i].ArrangePixel(new UIBox2i(finalPositionAsInt, finalPositionAsInt + items[i].DesiredPixelSize));
        }
    }

    /// <summary>
    /// Shrink a UIBox2 by a half extents, moving both the top-left and
    /// bottom-right closer together.
    /// </summary>
    private UIBox2 Shrink(UIBox2 box, Vector2 shrinkHe)
    {
        return new UIBox2(box.TopLeft + shrinkHe, box.BottomRight - shrinkHe);
    }

    /// <summary>
    /// Returns the input vector clamped to be within the UIBox
    /// </summary>
    private Vector2 Clamp(UIBox2 box, Vector2 point)
    {
        return Vector2.Min(box.BottomRight, Vector2.Max(box.TopLeft, point));
    }
}

